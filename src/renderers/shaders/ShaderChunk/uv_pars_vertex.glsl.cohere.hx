var fragmentSource = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n	varying vec2 vUv;\n\n#endif\n#ifdef USE_MAP\n\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varyMultiplier * vec4( reflectedLight.directDiffuse, material.specularRoughness );\n		} \n\n		#endif\n\n		#ifdef USE_SHADOWMAP\n\n		#ifdef USE_SHADOWMAP_DEBUG\n\n			reflectedLight.directSpecular += getShadowMask();\n\n		#else\n\n			reflectedLight.directSpecular += getShadowMask() * specularLightColor;\n\n		#endif\n\n		#endif\n\n		reflectedLight.directSpecular *= specularIntensity;\n\n		#endif\n\n		#ifdef METALNESSMAP\n\n			float metalnessFactor = metalness;\n			vec4 metalnessColor = texture2D( metalnessMap, vMetalnessMapUv );\n			metalnessFactor *= metalnessColor.r;\n\n		#else\n\n			float metalnessFactor = 1.0;\n\n		#endif\n\n		specularLight.color = mix( specularLight.color, vec3( max( max( specularLight.color.r, specularLight.color.g ), specularLight.color.b ) ), metalnessFactor );\n\n		#endif\n\n		#ifdef DOUBLE_SIDED\n\n			float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n			#endif\n\n		#ifdef USE_BUMPMAP\n\n			normal = perturbNormal2Arb( -vViewPosition, normal, dHdxy_fwd() );\n\n		#elif defined( USE_NORMALMAP )\n\n			normal = perturbNormal2Arb( -vViewPosition, normal, normalMap, normalScale );\n\n		#endif\n\n		#ifdef OBJECTSPACE_NORMALMAP\n\n			normal = transformDirection( normalMatrix, normal );\n			#endif\n\n		#ifdef REFLECTIONMAP_CUBEMAP\n\n			#ifdef BOXPROJECTION\n\n				// TODO: handle box projection\n\n			#else\n\n				reflectedLight.directSpecular = specularTexelToLinear( textureCube( reflectionCube, worldReflectVec ) );\n\n			#endif\n\n		#elif defined( USE_REFLECTIONMAP )\n\n			vec3 reflectionCoord = reflect( -normalize( viewDir ), normal );\n			#ifdef ENVMAP_TYPE_CUBE_UV\n\n				reflectionCoord = equirectUv( reflectionCoord );\n\n			#else\n\n				reflectionCoord = projectionEquirect( reflectionCoord );\n\n			#endif\n			reflectedLight.directSpecular = specularTexelToLinear( texture2D( reflectionMap, reflectionCoord * reflectionMapSize ) );\n\n		#endif\n\n		#ifdef REFLECTIONMAP_BLENDING_MIX\n\n			reflectedLight.directSpecular *= mixReflectivity;\n\n		#endif\n\n		#ifndef FLAT_SHADED\n\n			reflectedLight.directSpecular = reflectedLight.directSpecular * BRDF_Specular_GGX( normalize( normal ), normalize( viewDir ), specularLight.direction, roughness, specularIntensity );\n\n		#endif\n\n		reflectedLight.indirectDiffuse += PI * BRDF_Diffuse_Lambert( diffuseColor );\n\n		#ifdef USE_CLEARCOATMAP\n\n			vec4 clearcoat = texture2D( clearcoatMap, vClearcoatMapUv );\n			float cc = clearcoat.r;\n			#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n				vec4 clearcoatRoughness = texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv );\n				cc *= clearcoatRoughness.g;\n\n			#endif\n\n		#else\n\n			float cc = 0.0;\n\n		#endif\n\n		#ifdef USE_CLEARCOAT_NORMALMAP\n\n			vec3 clearcoatNormal;\n			clearcoatNormal.xy = clearcoatNormalMapTexelToLinear( texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ) ).xy;\n			clearcoatNormal.z = sqrt( max( 0.0, 1.0 - dot( clearcoatNormal.xy, clearcoatNormal.xy ) ) );\n			#ifdef CLEARCOAT_NORMALMAP_INVERT\n\n				clearcoatNormal = -clearcoatNormal;\n\n			#endif\n			#ifdef USE_TANGENT\n\n				clearcoatNormal = clearcoatNormal * tangent + clearcoatNormal * bitangent * clearcoatNormal.z;\n\n			#else\n\n				clearcoatNormal = clearcoatNormal * vec3( vUv.x, vUv.y, sqrt( 1.0 - vUv.x * vUv.x - vUv.y * vUv.y ) );\n\n			#endif\n			#endif\n\n		#ifdef USE_CLEARCOAT\n\n			reflectedLight.indirectSpecular += getClearcoatIndirectSpecular( cc, roughness, clearcoatNormal );\n\n		#endif\n\n		#ifdef USE_SHEEN\n\n			vec3 sheenColor = vec3( 1.0 );\n			#ifdef USE_SHEEN_COLORMAP\n\n				vec4 sheenColorMap = texture2D( sheenColorMap, vSheenColorMapUv );\n				sheenColor = sheenColorMap.rgb;\n\n			#endif\n			float sheenRoughness = 0.0;\n			#ifdef USE_SHEEN_ROUGHNESSMAP\n\n				vec4 sheenRoughnessMap = texture2D( sheenRoughnessMap, vSheenRoughnessMapUv );\n				sheenRoughness = sheenRoughnessMap.g;\n\n			#endif\n			reflectedLight.indirectSpecular += getSheenIndirectSpecular( sheenColor, sheenRoughness, normal, viewDir );\n\n		#endif\n\n		#ifdef USE_TRANSMISSION\n\n			reflectedLight.indirectTransmission += getTransmissionIndirect( transmission, transmissionRoughness, normal, viewDir );\n\n		#endif\n\n		#ifdef USE_IRIDESCENCE\n\n			vec3 iridescenceColor = vec3( 1.0 );\n			#ifdef USE_IRIDESCENCEMAP\n\n				vec4 iridescenceMap = texture2D( iridescenceMap, vIridescenceMapUv );\n				iridescenceColor = iridescenceMap.rgb;\n\n			#endif\n			float iridescenceThickness = 1.0;\n			#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n				vec4 iridescenceThicknessMap = texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv );\n				iridescenceThickness = iridescenceThicknessMap.g;\n\n			#endif\n			reflectedLight.indirectSpecular += getIridescenceIndirectSpecular( iridescenceColor, iridescenceThickness, normal, viewDir );\n\n		#endif\n\n		outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + reflectedLight.indirectTransmission;\n\n		#ifdef PREMULTIPLIED_ALPHA\n\n			outgoingLight = premultiply( outgoingLight, diffuseColor.a );\n\n		#endif\n\n		#ifdef USE_FOG\n\n			#ifdef USE_LOGDEPTHBUF_EXT\n\n				float depth = gl_FragDepthEXT / gl_FragCoord.w;\n				float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n			#else\n\n				float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n			#endif\n\n			outgoingLight = mix( fogColor, outgoingLight, fogFactor );\n\n		#endif\n\n		gl_FragColor = vec4( outgoingLight, material.opacity );\n\n		#ifdef TONE_MAPPING\n\n			gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n		#endif\n\n		#ifdef GAMMA_OUTPUT\n\n			gl_FragColor.rgb = linearToOutputTexel( gl_FragColor.rgb );\n\n		#endif\n\n	};