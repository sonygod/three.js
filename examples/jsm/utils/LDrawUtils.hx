package three.js.examples.jsm.utils;

import three.BufferAttribute;
import three.BufferGeometry;
import three.Group;
import three.LineSegments;
import three.Matrix3;
import three.Mesh;

import BufferGeometryUtils.mergeGeometries;

class LDrawUtils {
  public static function mergeObject(object:three.Object3D):three.Group {
    // Merges geometries in object by materials and returns new object. Use on not indexed geometries.
    // The object buffers reference the old object ones.
    // Special treatment is done to the conditional lines generated by LDrawLoader.

    function extractGroup(geometry:BufferGeometry, group:three.Group, elementSize:Int, isConditionalLine:Bool):BufferGeometry {
      // Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)

      var newGeometry:BufferGeometry = new BufferGeometry();

      var originalPositions:Array<Float> = geometry.getAttribute('position').array;
      var originalNormals:Array<Float> = elementSize == 3 ? geometry.getAttribute('normal').array : null;

      var numVertsGroup:Int = Math.min(group.count, Math.floor(originalPositions.length / 3) - group.start);
      var vertStart:Int = group.start * 3;
      var vertEnd:Int = (group.start + numVertsGroup) * 3;

      var positions:Array<Float> = originalPositions.subarray(vertStart, vertEnd);
      var normals:Array<Float> = originalNormals != null ? originalNormals.subarray(vertStart, vertEnd) : null;

      newGeometry.setAttribute('position', new BufferAttribute(positions, 3));
      if (normals != null) newGeometry.setAttribute('normal', new BufferAttribute(normals, 3));

      if (isConditionalLine) {
        var controlArray0:Array<Float> = geometry.getAttribute('control0').array.subarray(vertStart, vertEnd);
        var controlArray1:Array<Float> = geometry.getAttribute('control1').array.subarray(vertStart, vertEnd);
        var directionArray:Array<Float> = geometry.getAttribute('direction').array.subarray(vertStart, vertEnd);

        newGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));
        newGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));
        newGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));
      }

      return newGeometry;
    }

    function addGeometry(mat:three.Material, geometry:BufferGeometry, geometries:Map<String, { mat:three.Material, arr:Array<BufferGeometry> }>):Void {
      var geoms:Dynamic = geometries[mat.uuid];
      if (!geoms) {
        geometries[mat.uuid] = {
          mat: mat,
          arr: [geometry]
        };
      } else {
        geoms.arr.push(geometry);
      }
    }

    function permuteAttribute(attribute:BufferAttribute, elemSize:Int):Void {
      // Permutes first two vertices of each attribute element

      if (attribute == null) return;

      var verts:Array<Float> = attribute.array;
      var numVerts:Int = Math.floor(verts.length / 3);
      var offset:Int = 0;
      for (i in 0...numVerts) {
        var x:Float = verts[offset];
        var y:Float = verts[offset + 1];
        var z:Float = verts[offset + 2];

        verts[offset] = verts[offset + 3];
        verts[offset + 1] = verts[offset + 4];
        verts[offset + 2] = verts[offset + 5];

        verts[offset + 3] = x;
        verts[offset + 4] = y;
        verts[offset + 5] = z;

        offset += elemSize * 3;
      }
    }

    // Traverse the object hierarchy collecting geometries and transforming them to world space

    var meshGeometries:Map<String, { mat:three.Material, arr:Array<BufferGeometry> }> = {};
    var linesGeometries:Map<String, { mat:three.Material, arr:Array<BufferGeometry> }> = {};
    var condLinesGeometries:Map<String, { mat:three.Material, arr:Array<BufferGeometry> }> = {};

    object.updateMatrixWorld(true);
    var normalMatrix:Matrix3 = new Matrix3();

    object.traverse(function(c:three.Object3D) {
      if (c.isMesh || c.isLineSegments) {
        var elemSize:Int = c.isMesh ? 3 : 2;

        var geometry:BufferGeometry = c.geometry.clone();
        var matrixIsInverted:Bool = c.matrixWorld.determinant() < 0;
        if (matrixIsInverted) {
          permuteAttribute(geometry.attributes.position, elemSize);
          permuteAttribute(geometry.attributes.normal, elemSize);
        }

        geometry.applyMatrix4(c.matrixWorld);

        if (c.isConditionalLine) {
          geometry.attributes.control0.applyMatrix4(c.matrixWorld);
          geometry.attributes.control1.applyMatrix4(c.matrixWorld);
          normalMatrix.getNormalMatrix(c.matrixWorld);
          geometry.attributes.direction.applyNormalMatrix(normalMatrix);
        }

        var geometries:Map<String, { mat:three.Material, arr:Array<BufferGeometry> }> = c.isMesh ? meshGeometries : (c.isConditionalLine ? condLinesGeometries : linesGeometries);

        if (c.material.isArray()) {
          for (groupIndex in geometry.groups) {
            var group:three.Group = geometry.groups[groupIndex];
            var mat:three.Material = c.material[group.materialIndex];
            var newGeometry:BufferGeometry = extractGroup(geometry, group, elemSize, c.isConditionalLine);
            addGeometry(mat, newGeometry, geometries);
          }
        } else {
          addGeometry(c.material, geometry, geometries);
        }
      }
    });

    // Create object with merged geometries

    var mergedObject:Group = new Group();

    for (meshMaterialsId in meshGeometries.keys()) {
      var meshGeometry:Dynamic = meshGeometries[meshMaterialsId];
      var mergedGeometry:BufferGeometry = mergeGeometries(meshGeometry.arr);
      mergedObject.add(new Mesh(mergedGeometry, meshGeometry.mat));
    }

    for (linesMaterialsId in linesGeometries.keys()) {
      var lineGeometry:Dynamic = linesGeometries[linesMaterialsId];
      var mergedGeometry:BufferGeometry = mergeGeometries(lineGeometry.arr);
      mergedObject.add(new LineSegments(mergedGeometry, lineGeometry.mat));
    }

    for (condLinesMaterialsId in condLinesGeometries.keys()) {
      var condLineGeometry:Dynamic = condLinesGeometries[condLinesMaterialsId];
      var mergedGeometry:BufferGeometry = mergeGeometries(condLineGeometry.arr);
      var condLines:LineSegments = new LineSegments(mergedGeometry, condLineGeometry.mat);
      condLines.isConditionalLine = true;
      mergedObject.add(condLines);
    }

    mergedObject.userData.constructionStep = 0;
    mergedObject.userData.numConstructionSteps = 1;

    return mergedObject;
  }
}