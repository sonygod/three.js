import three.js.BufferAttribute;
import three.js.BufferGeometry;
import three.js.Group;
import three.js.LineSegments;
import three.js.Matrix3;
import three.js.Mesh;

class LDrawUtils {
    static function mergeObject(object:Dynamic) {
        // Merges geometries in object by materials and returns new object. Use on not indexed geometries.
        // The object buffers reference the old object ones.
        // Special treatment is done to the conditional lines generated by LDrawLoader.

        function extractGroup(geometry:BufferGeometry, group: Dynamic, elementSize:Int, isConditionalLine:Bool) {
            // Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)

            var newGeometry = new BufferGeometry();

            var originalPositions:Array<Float> = geometry.getAttribute('position').array;
            var originalNormals:Array<Float> = elementSize == 3 ? geometry.getAttribute('normal').array : null;

            var numVertsGroup:Int = Math.min(group.count, Math.floor(originalPositions.length / 3) - group.start);
            var vertStart:Int = group.start * 3;
            var vertEnd:Int = (group.start + numVertsGroup) * 3;

            var positions:Array<Float> = originalPositions.subarray(vertStart, vertEnd);
            var normals:Array<Float> = originalNormals != null ? originalNormals.subarray(vertStart, vertEnd) : null;

            newGeometry.setAttribute('position', new BufferAttribute(positions, 3));
            if (normals != null) newGeometry.setAttribute('normal', new BufferAttribute(normals, 3));

            if (isConditionalLine) {
                var controlArray0:Array<Float> = geometry.getAttribute('control0').array.subarray(vertStart, vertEnd);
                var controlArray1:Array<Float> = geometry.getAttribute('control1').array.subarray(vertStart, vertEnd);
                var directionArray:Array<Float> = geometry.getAttribute('direction').array.subarray(vertStart, vertEnd);

                newGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));
                newGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));
                newGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));
            }

            return newGeometry;
        }

        function addGeometry(mat:Dynamic, geometry:BufferGeometry, geometries:Dynamic) {
            var geoms:Dynamic = geometries[mat.uuid];
            if (!geoms) {
                geometries[mat.uuid] = {
                    mat: mat,
                    arr: [geometry]
                };
            } else {
                geoms.arr.push(geometry);
            }
        }

        function permuteAttribute(attribute:BufferAttribute, elemSize:Int) {
            // Permutes first two vertices of each attribute element

            if (attribute == null) return;

            var verts:Array<Float> = attribute.array;
            var numVerts:Int = Math.floor(verts.length / 3);
            var offset:Int = 0;
            for (i in 0...numVerts) {
                var x:Float = verts[offset];
                var y:Float = verts[offset + 1];
                var z:Float = verts[offset + 2];

                verts[offset] = verts[offset + 3];
                verts[offset + 1] = verts[offset + 4];
                verts[offset + 2] = verts[offset + 5];

                verts[offset + 3] = x;
                verts[offset + 4] = y;
                verts[offset + 5] = z;

                offset += elemSize * 3;
            }
        }

        // Traverse the object hierarchy collecting geometries and transforming them to world space

        var meshGeometries:Dynamic = {};
        var linesGeometries:Dynamic = {};
        var condLinesGeometries:Dynamic = {};

        object.updateMatrixWorld(true);
        var normalMatrix:Matrix3 = new Matrix3();

        object.traverse(function(c:Dynamic) {
            if (c.isMesh || c.isLineSegments) {
                var elemSize:Int = c.isMesh ? 3 : 2;

                var geometry:BufferGeometry = c.geometry.clone();
                var matrixIsInverted:Bool = c.matrixWorld.determinant() < 0;
                if (matrixIsInverted) {
                    permuteAttribute(geometry.attributes.position, elemSize);
                    permuteAttribute(geometry.attributes.normal, elemSize);
                }

                geometry.applyMatrix4(c.matrixWorld);

                if (c.isConditionalLine) {
                    geometry.attributes.control0.applyMatrix4(c.matrixWorld);
                    geometry.attributes.control1.applyMatrix4(c.matrixWorld);
                    normalMatrix.getNormalMatrix(c.matrixWorld);
                    geometry.attributes.direction.applyNormalMatrix(normalMatrix);
                }

                var geometries:Dynamic = c.isMesh ? meshGeometries : (c.isConditionalLine ? condLinesGeometries : linesGeometries);

                if (Array.isArray(c.material)) {
                    for (groupIndex in geometry.groups.keys()) {
                        var group:Dynamic = geometry.groups[groupIndex];
                        var mat:Dynamic = c.material[group.materialIndex];
                        var newGeometry:BufferGeometry = extractGroup(geometry, group, elemSize, c.isConditionalLine);
                        addGeometry(mat, newGeometry, geometries);
                    }
                } else {
                    addGeometry(c.material, geometry, geometries);
                }
            }
        });

        // Create object with merged geometries

        var mergedObject:Group = new Group();

        var meshMaterialsIds:Array<String> = Object.keys(meshGeometries);
        for (meshMaterialsId in meshMaterialsIds) {
            var meshGeometry:Dynamic = meshGeometries[meshMaterialsId];
            var mergedGeometry:BufferGeometry = mergeGeometries(meshGeometry.arr);
            mergedObject.add(new Mesh(mergedGeometry, meshGeometry.mat));
        }

        var linesMaterialsIds:Array<String> = Object.keys(linesGeometries);
        for (linesMaterialsId in linesMaterialsIds) {
            var lineGeometry:Dynamic = linesGeometries[linesMaterialsId];
            var mergedGeometry:BufferGeometry = mergeGeometries(lineGeometry.arr);
            mergedObject.add(new LineSegments(mergedGeometry, lineGeometry.mat));
        }

        var condLinesMaterialsIds:Array<String> = Object.keys(condLinesGeometries);
        for (condLinesMaterialsId in condLinesMaterialsIds) {
            var condLineGeometry:Dynamic = condLinesGeometries[condLinesMaterialsId];
            var mergedGeometry:BufferGeometry = mergeGeometries(condLineGeometry.arr);
            var condLines:LineSegments = new LineSegments(mergedGeometry, condLineGeometry.mat);
            condLines.isConditionalLine = true;
            mergedObject.add(condLines);
        }

        mergedObject.userData.constructionStep = 0;
        mergedObject.userData.numConstructionSteps = 1;

        return mergedObject;
    }
}